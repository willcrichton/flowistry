<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="This crate helps with defining “newtype”-style wrappers around `usize` (or other integers), `Vec&lt;T&gt;`, and `[T]` so that some additional type safety can be gained at zero cost."><title>index_vec - Rust</title><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/SourceSerif4-Regular-46f98efaafac5295.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/FiraSans-Regular-018c141bf0843ffd.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/FiraSans-Medium-8f9a781e4970d388.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/SourceCodePro-Regular-562dcc5011b6de7d.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/SourceSerif4-Bold-a2c9cd1067f8b328.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/SourceCodePro-Semibold-d899c5a5c4aeb14a.ttf.woff2"><link rel="stylesheet" href="../static.files/normalize-76eba96aa4d2e634.css"><link rel="stylesheet" href="../static.files/rustdoc-47e7ab555ef2818a.css" id="mainThemeStyle"><meta name="rustdoc-vars" data-root-path="../" data-static-root-path="../static.files/" data-current-crate="index_vec" data-themes="" data-resource-suffix="" data-rustdoc-version="1.74.0-nightly (58eefc33a 2023-08-24)" data-channel="nightly" data-search-js="search-6dfdfced5eff6596.js" data-settings-js="settings-de11bff964e9d4e5.js" data-settings-css="settings-8c76f75bfb6bd192.css" data-theme-light-css="light-b2d31d2efc7e9b67.css" data-theme-dark-css="dark-3388a2fb2ef8066b.css" data-theme-ayu-css="ayu-8c3c66a6cf12cb2f.css" ><script src="../static.files/storage-db41da1a38ea3cb8.js"></script><script defer src="../crates.js"></script><script defer src="../static.files/main-ef3a2de404864b0b.js"></script><noscript><link rel="stylesheet" media="(prefers-color-scheme:light)" href="../static.files/light-b2d31d2efc7e9b67.css"><link rel="stylesheet" media="(prefers-color-scheme:dark)" href="../static.files/dark-3388a2fb2ef8066b.css"><link rel="stylesheet" href="../static.files/noscript-cffde32267a19fd6.css"></noscript><link rel="alternate icon" type="image/png" href="../static.files/favicon-16x16-8b506e7a72182f1c.png"><link rel="alternate icon" type="image/png" href="../static.files/favicon-32x32-422f7d1d52889060.png"><link rel="icon" type="image/svg+xml" href="../static.files/favicon-2c020d218678b618.svg"></head><body class="rustdoc mod crate"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle">&#9776;</button><a class="logo-container" href="../index_vec/index.html"><img class="rust-logo" src="../static.files/rust-logo-151179464ae7ed46.svg" alt="logo"></a><h2></h2></nav><nav class="sidebar"><a class="logo-container" href="../index_vec/index.html"><img class="rust-logo" src="../static.files/rust-logo-151179464ae7ed46.svg" alt="logo"></a><h2 class="location"><a href="#">Crate index_vec</a></h2><div class="sidebar-elems"><ul class="block"><li class="version">Version 0.1.3</li><li><a id="all-types" href="all.html">All Items</a></li></ul><section><ul class="block"><li><a href="#macros">Macros</a></li><li><a href="#structs">Structs</a></li><li><a href="#traits">Traits</a></li><li><a href="#types">Type Aliases</a></li></ul></section></div></nav><main><div class="width-limiter"><nav class="sub"><form class="search-form"><span></span><input class="search-input" name="search" aria-label="Run search in the documentation" autocomplete="off" spellcheck="false" placeholder="Click or press ‘S’ to search, ‘?’ for more options…" type="search"><div id="help-button" title="help" tabindex="-1"><a href="../help.html">?</a></div><div id="settings-menu" tabindex="-1"><a href="../settings.html" title="settings"><img width="22" height="22" alt="Change settings" src="../static.files/wheel-7b819b6101059cd0.svg"></a></div></form></nav><section id="main-content" class="content"><div class="main-heading"><h1>Crate <a class="mod" href="#">index_vec</a><button id="copy-path" title="Copy item path to clipboard"><img src="../static.files/clipboard-7571035ce49a181d.svg" width="19" height="18" alt="Copy item path"></button></h1><span class="out-of-band"><a class="src" href="../src/index_vec/lib.rs.html#1-806">source</a> · <button id="toggle-all-docs" title="collapse all docs">[<span>&#x2212;</span>]</button></span></div><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>This crate helps with defining “newtype”-style wrappers around <code>usize</code> (or
other integers), <code>Vec&lt;T&gt;</code>, and <code>[T]</code> so that some additional type safety can
be gained at zero cost.</p>
<h3 id="example--overview"><a href="#example--overview">Example / Overview</a></h3>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>index_vec::{IndexVec, IndexSlice, index_vec};

<span class="macro">index_vec::define_index_type! </span>{
    <span class="comment">// Define StrIdx to use only 32 bits internally (you can use usize, u16,
    // and even u8).
    </span><span class="kw">pub struct </span>StrIdx = u32;

    <span class="comment">// The defaults are very reasonable, but this macro can let
    // you customize things quite a bit:

    // By default, creating a StrIdx would check an incoming `usize against
    // `u32::max_value()`, as u32 is the wrapped index type. Lets imagine that
    // StrIdx has to interface with an external system that uses signed ints.
    // We can change the checking behavior to complain on i32::max_value()
    // instead:
    </span>MAX_INDEX = i32::max_value() <span class="kw">as </span>usize;

    <span class="comment">// We can also disable checking all-together if we are more concerned with perf
    // than any overflow problems, or even do so, but only for debug builds: Quite
    // pointless here, but an okay example
    </span>DISABLE_MAX_INDEX_CHECK = <span class="macro">cfg!</span>(not(debug_assertions));

    <span class="comment">// And more too, see this macro&#39;s docs for more info.
</span>}

<span class="comment">// Create a vector which can be accessed using `StrIdx`s.
</span><span class="kw">let </span><span class="kw-2">mut </span>strs: IndexVec&lt;StrIdx, <span class="kw-2">&amp;</span><span class="lifetime">&#39;static </span>str&gt; = <span class="macro">index_vec!</span>[<span class="string">&quot;strs&quot;</span>, <span class="string">&quot;bar&quot;</span>, <span class="string">&quot;baz&quot;</span>];

<span class="comment">// l is a `StrIdx`
</span><span class="kw">let </span>l = strs.last_idx();
<span class="macro">assert_eq!</span>(strs[l], <span class="string">&quot;baz&quot;</span>);

<span class="kw">let </span>new_i = strs.push(<span class="string">&quot;quux&quot;</span>);
<span class="macro">assert_eq!</span>(strs[new_i], <span class="string">&quot;quux&quot;</span>);

<span class="comment">// The slice APIs are wrapped as well.
</span><span class="kw">let </span>s: <span class="kw-2">&amp;</span>IndexSlice&lt;StrIdx, [<span class="kw-2">&amp;</span><span class="lifetime">&#39;static </span>str]&gt; = <span class="kw-2">&amp;</span>strs[StrIdx::new(<span class="number">1</span>)..];
<span class="macro">assert_eq!</span>(s[<span class="number">0</span>], <span class="string">&quot;bar&quot;</span>);

<span class="comment">// Indices are mostly interoperable with `usize`, and support
// a lot of what you might want to do to an index.

// Comparison
</span><span class="macro">assert_eq!</span>(StrIdx::new(<span class="number">0</span>), <span class="number">0usize</span>);

<span class="comment">// Addition
</span><span class="macro">assert_eq!</span>(StrIdx::new(<span class="number">0</span>) + <span class="number">1</span>, <span class="number">1usize</span>);

<span class="comment">// Subtraction
</span><span class="macro">assert_eq!</span>(StrIdx::new(<span class="number">1</span>) - <span class="number">1</span>, <span class="number">0usize</span>);

<span class="comment">// Wrapping
</span><span class="macro">assert_eq!</span>(StrIdx::new(<span class="number">5</span>) % strs.len(), <span class="number">1usize</span>);
<span class="comment">// ...</span></code></pre></div>
<h3 id="background"><a href="#background">Background</a></h3>
<p>The goal is to help with the pattern of using a <code>type FooIdx = usize</code> to
access a <code>Vec&lt;Foo&gt;</code> with something that can statically prevent using a
<code>FooIdx</code> in a <code>Vec&lt;Bar&gt;</code>. It’s most useful if you have a bunch of indices
referring to different sorts of vectors.</p>
<p>The code was originally based on <code>rustc</code>’s <code>IndexVec</code> code, however that has
been almost entirely rewritten (except for the cases where it’s trivial,
e.g. the Vec wrapper).</p>
<h3 id="other-crates"><a href="#other-crates">Other crates</a></h3>
<p>The <a href="https://crates.io/crates/indexed_vec"><code>indexed_vec</code></a> crate predates
this, and is a much closer copy of the code from <code>rustc</code>. Unfortunately,
this means it does not compile on stable.</p>
<p>If you’re looking for something further from a vec and closer to a map, you
might find <a href="https://crates.io/crates/handy"><code>handy</code></a>,
<a href="https://crates.io/crates/slotmap"><code>slotmap</code></a>, or
<a href="https://crates.io/crates/slab"><code>slab</code></a> to be closer what you want.</p>
<h3 id="faq"><a href="#faq">FAQ</a></h3><h5 id="wouldnt-define_index_type-be-better-as-a-proc-macro"><a href="#wouldnt-define_index_type-be-better-as-a-proc-macro">Wouldn’t <code>define_index_type</code> be better as a proc macro?</a></h5>
<p>Probably. It’s not a proc macro because I tend to avoid them where possible
due to wanting to minimize compile times. If the issues around proc-macro
compile times are fixed, then I’ll revisit this.</p>
<p>I also may eventually add a proc-macro feature which is not required, but
avoids some of the grossness.</p>
<h5 id="does-define_index_type-do-too-much"><a href="#does-define_index_type-do-too-much">Does <code>define_index_type</code> do too much?</a></h5>
<p>Possibly. It defines a type, implements a bunch of functions on it, and
quite a few traits. That said, it’s intended to be a very painless journey
from <code>Vec&lt;T&gt;</code> + <code>usize</code> to <code>IndexVec&lt;I, T&gt;</code>. If it left it up to the
developer to do those things, it would be too annoying to be worth using.</p>
<h5 id="the-syntax-for-the-options-in-define_index_type-is-terrible"><a href="#the-syntax-for-the-options-in-define_index_type-is-terrible">The syntax for the options in <code>define_index_type</code> is terrible.</a></h5>
<p>I’m open to suggestions.</p>
<h5 id="does-it-support-no_std"><a href="#does-it-support-no_std">Does it support no_std?</a></h5>
<p>Yes, although it uses <code>extern crate alloc;</code>, of course.</p>
<h5 id="does-it-support-serde"><a href="#does-it-support-serde">Does it support serde?</a></h5>
<p>Yes, but only if you turn on the <code>serde</code> feature.</p>
<h5 id="what-features-are-planned"><a href="#what-features-are-planned">What features are planned?</a></h5>
<p>Planned is a bit strong but here are the things I would find useful.</p>
<ul>
<li>Support any remaining parts of the slice/vec api.</li>
<li>Add typesafe wrappers for SmallVec/ArrayVec (behind a cargo <code>feature</code>, of
course).</li>
<li>Better syntax for the define_index_type macro (no concrete ideas).</li>
<li>Allow the generated type to be a tuple struct, or use a specific field
name.</li>
<li>Allow use of indices for string types (the primary benefit here would
probably be the ability to e.g. use u32 without too much pain rather than
mixing up indices from different strings – but you never know!)</li>
<li>Allow index types such as NonZeroU32 and such, if it can be done sanely.</li>
<li>…</li>
</ul>
</div></details><h2 id="macros" class="small-section-header"><a href="#macros">Macros</a></h2><ul class="item-table"><li><div class="item-name"><a class="macro" href="macro.define_index_type.html" title="macro index_vec::define_index_type">define_index_type</a></div><div class="desc docblock-short">Generate the boilerplate for a newtyped index struct, for use with
<code>IndexVec</code>.</div></li><li><div class="item-name"><a class="macro" href="macro.index_box.html" title="macro index_vec::index_box">index_box</a></div><div class="desc docblock-short">A macro similar to the stdlib’s <code>vec![]</code>, but producing an
<code>Box&lt;IndexSlice&lt;I, [T]&gt;&gt;</code> (That is, an <code>IndexBox&lt;I, [T]&gt;</code>).</div></li><li><div class="item-name"><a class="macro" href="macro.index_vec.html" title="macro index_vec::index_vec">index_vec</a></div><div class="desc docblock-short">A macro equivalent to the stdlib’s <code>vec![]</code>, but producing an <code>IndexVec</code>.</div></li></ul><h2 id="structs" class="small-section-header"><a href="#structs">Structs</a></h2><ul class="item-table"><li><div class="item-name"><a class="struct" href="struct.IndexSlice.html" title="struct index_vec::IndexSlice">IndexSlice</a></div><div class="desc docblock-short">A slice that only accepts indices of a specific type. Note that the intended
usage is as <code>IndexSlice&lt;I, [T]&gt;</code>.</div></li><li><div class="item-name"><a class="struct" href="struct.IndexVec.html" title="struct index_vec::IndexVec">IndexVec</a></div><div class="desc docblock-short">A Vec that only accepts indices of a specific type.</div></li></ul><h2 id="traits" class="small-section-header"><a href="#traits">Traits</a></h2><ul class="item-table"><li><div class="item-name"><a class="trait" href="trait.Idx.html" title="trait index_vec::Idx">Idx</a></div><div class="desc docblock-short">Represents a wrapped value convertable to and from a <code>usize</code>.</div></li><li><div class="item-name"><a class="trait" href="trait.IdxRangeBounds.html" title="trait index_vec::IdxRangeBounds">IdxRangeBounds</a></div><div class="desc docblock-short">This trait to function in API signatures where <code>Vec&lt;T&gt;</code> or <code>[T]</code> use <code>R: RangeBounds&lt;usize&gt;</code>. There are blanket implementations for the basic range
types in <code>core::ops</code> for all Idx types. e.g. <code>Range&lt;I: Idx&gt;</code>, <code>RangeFrom&lt;I: Idx&gt;</code>, <code>RangeTo&lt;I: Idx&gt;</code>, etc all implement it.</div></li><li><div class="item-name"><a class="trait" href="trait.IdxSliceIndex.html" title="trait index_vec::IdxSliceIndex">IdxSliceIndex</a></div><div class="desc docblock-short">This is the equivalent of the sealed <code>core::slice::SliceIndex</code> trait. It
cannot be overridden from user, code nor should it normally need use
directly (Outside of trait bounds, I guess).</div></li></ul><h2 id="types" class="small-section-header"><a href="#types">Type Aliases</a></h2><ul class="item-table"><li><div class="item-name"><a class="type" href="type.IndexBox.html" title="type index_vec::IndexBox">IndexBox</a></div><div class="desc docblock-short"><code>IndexBox&lt;I, [T]&gt;</code>: An alias for indexed boxed slice.</div></li></ul></section></div></main></body></html>